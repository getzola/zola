use std::borrow::Cow;
use std::path::PathBuf;
use std::sync::Arc;

use derive_builder::Builder;
use libs::dashmap::DashMap;

use config::Config;
use errors::Result;

mod compress;
mod encrypt;
mod livereload;
mod minify;

pub use compress::CompressionMiddleware;
pub use encrypt::EncryptionMiddleware;
pub use livereload::LiveReloadMiddleware;
pub use minify::MinifyMiddleware;

/// Trait for middleware that can process rendered content
pub trait Middleware: Send + Sync {
    /// Process the output package - can modify existing outputs or add new ones
    fn process(&self, package: &mut OutputPackage) -> Result<()>;

    /// Name of the middleware for debugging/logging
    fn name(&self) -> &str;
}

/// Key for output map - represents full path to output file
#[derive(Hash, Eq, PartialEq, Clone, Debug)]
pub struct OutputKey {
    pub components: Vec<String>,
    pub filename: String,
}

impl OutputKey {
    pub fn new(components: Vec<String>, filename: impl Into<String>) -> Self {
        Self { components, filename: filename.into() }
    }

    pub fn root(filename: impl Into<String>) -> Self {
        Self { components: Vec::new(), filename: filename.into() }
    }
}

/// Output data - either text or binary
#[derive(Clone, Debug)]
pub enum OutputData {
    /// Text content (will be written as UTF-8)
    Text(String),
    /// Binary content
    Binary(Vec<u8>),
}

impl OutputData {
    /// Convert to bytes for writing
    pub fn as_bytes(&self) -> Cow<'_, [u8]> {
        match self {
            OutputData::Text(s) => Cow::Borrowed(s.as_bytes()),
            OutputData::Binary(b) => Cow::Borrowed(b),
        }
    }

    /// Get as string if it's text
    pub fn as_text(&self) -> Option<&str> {
        match self {
            OutputData::Text(s) => Some(s),
            OutputData::Binary(_) => None,
        }
    }

    /// Get mutable reference to text if it's text
    pub fn as_text_mut(&mut self) -> Option<&mut String> {
        match self {
            OutputData::Text(s) => Some(s),
            OutputData::Binary(_) => None,
        }
    }
}

/// A single output file in the package
#[derive(Clone, Debug)]
pub struct Output {
    /// The actual content
    pub data: OutputData,
    /// Content type for middleware decision-making
    pub content_type: ContentType,
    /// Tags to help middleware decide what to process
    pub tags: OutputTags,
}

/// Tags for outputs to help middleware make decisions
#[derive(Clone, Debug, Default)]
pub struct OutputTags {
    /// The original rendered output (not derived)
    pub is_primary: bool,
    /// Already compressed
    pub is_compressed: bool,
    /// Already minified
    pub is_minified: bool,
    /// Generated by middleware (not from template)
    pub is_derived: bool,
    /// Virtual output that should not be written to disk or memory
    /// Useful for intermediate processing data that middleware can share
    pub is_virtual: bool,
}

/// Package of outputs that flow through middleware together
///
/// # Virtual Outputs
///
/// Middleware can create "virtual" outputs that exist only for inter-middleware communication
/// and are not written to disk or memory. This is useful for passing intermediate processing
/// data between middleware stages.
///
/// # Example
///
/// ```rust,ignore
/// use middleware::{Output, OutputData, OutputTags, ContentType};
///
/// // Middleware 1: Extract metadata and store as virtual output
/// impl Middleware for MetadataExtractor {
///     fn process(&self, package: &mut OutputPackage) -> Result<()> {
///         // Extract some data from the primary output
///         let metadata = extract_metadata(package)?;
///
///         // Store as virtual output for other middleware to access
///         package.add_virtual(
///             "metadata.json",
///             Output {
///                 data: OutputData::Text(serde_json::to_string(&metadata)?),
///                 content_type: ContentType::Json,
///                 tags: OutputTags::default(), // is_virtual will be set automatically
///             }
///         );
///
///         Ok(())
///     }
/// }
///
/// // Middleware 2: Use the virtual output
/// impl Middleware for MetadataConsumer {
///     fn process(&self, package: &mut OutputPackage) -> Result<()> {
///         // Access the virtual output created by previous middleware
///         if let Some(metadata_output) = package.get("metadata.json") {
///             let metadata: Metadata = serde_json::from_str(
///                 metadata_output.data.as_text().unwrap()
///             )?;
///             // Use metadata...
///         }
///
///         Ok(())
///     }
/// }
/// ```
pub struct OutputPackage {
    /// All outputs indexed by path
    pub outputs: DashMap<OutputKey, Output>,
    /// Metadata about the source renderable
    pub source_metadata: ContentMetadata,
    /// Site configuration
    pub config: Arc<Config>,
}

impl OutputPackage {
    /// Create new output package with a primary output
    pub fn new(content: String, metadata: ContentMetadata, config: Arc<Config>) -> Self {
        let outputs = DashMap::new();

        let key = OutputKey::new(metadata.components.clone(), metadata.filename.clone());
        let output = Output {
            data: OutputData::Text(content),
            content_type: metadata.content_type.clone(),
            tags: OutputTags { is_primary: true, ..Default::default() },
        };

        outputs.insert(key, output);

        Self { outputs, source_metadata: metadata, config }
    }

    /// Add output at the source's location (inherits components from source)
    pub fn add(&self, filename: impl Into<String>, output: Output) -> Option<Output> {
        let key = OutputKey::new(self.source_metadata.components.clone(), filename);
        self.outputs.insert(key, output)
    }

    /// Add output at custom location
    pub fn add_at(
        &self,
        components: Vec<String>,
        filename: impl Into<String>,
        output: Output,
    ) -> Option<Output> {
        let key = OutputKey::new(components, filename);
        self.outputs.insert(key, output)
    }

    /// Add virtual output at the source's location (inherits components from source)
    /// Virtual outputs are not written to disk or memory - they exist only for middleware communication
    pub fn add_virtual(&self, filename: impl Into<String>, mut output: Output) -> Option<Output> {
        output.tags.is_virtual = true;
        output.tags.is_derived = true;
        let key = OutputKey::new(self.source_metadata.components.clone(), filename);
        self.outputs.insert(key, output)
    }

    /// Add virtual output at custom location
    /// Virtual outputs are not written to disk or memory - they exist only for middleware communication
    pub fn add_virtual_at(
        &self,
        components: Vec<String>,
        filename: impl Into<String>,
        mut output: Output,
    ) -> Option<Output> {
        output.tags.is_virtual = true;
        output.tags.is_derived = true;
        let key = OutputKey::new(components, filename);
        self.outputs.insert(key, output)
    }

    /// Get output by filename at source location
    pub fn get(
        &self,
        filename: &str,
    ) -> Option<libs::dashmap::mapref::one::Ref<'_, OutputKey, Output>> {
        let key = OutputKey::new(self.source_metadata.components.clone(), filename);
        self.outputs.get(&key)
    }

    /// Check if output exists at source location
    pub fn contains(&self, filename: &str) -> bool {
        let key = OutputKey::new(self.source_metadata.components.clone(), filename);
        self.outputs.contains_key(&key)
    }
}

/// Metadata about the content being processed
#[derive(Clone, Debug, Builder)]
#[builder(setter(into, strip_option), build_fn(error = "String"))]
pub struct ContentMetadata {
    /// Source file path
    #[builder(default)]
    pub path: PathBuf,

    /// Output path components (e.g., ["blog", "my-post"])
    #[builder(default)]
    pub components: Vec<String>,

    /// Output filename (e.g., "index.html")
    #[builder(default = "String::from(\"index.html\")")]
    pub filename: String,

    /// Template name used to render (e.g., "page.html")
    #[builder(default = "String::from(\"index.html\")", setter(custom))]
    pub template_name: String,

    /// Content type based on template extension
    #[builder(default = "ContentType::Html")]
    pub content_type: ContentType,

    /// Language code
    #[builder(default)]
    pub language: String,

    /// Permalink URL
    #[builder(default)]
    pub permalink: String,
}

impl ContentMetadata {
    /// Create a new builder for ContentMetadata
    pub fn builder() -> ContentMetadataBuilder {
        ContentMetadataBuilder::default()
    }
}

impl ContentMetadataBuilder {
    /// Custom setter for template_name that automatically sets content_type
    pub fn template_name(&mut self, template_name: impl Into<String>) -> &mut Self {
        let name = template_name.into();
        self.content_type = Some(ContentType::from_template(&name));
        self.template_name = Some(name);
        self
    }
}

/// Content type determined from template extension
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ContentType {
    Html,
    Xml,
    Text,
    Json,
}

impl ContentType {
    /// Determine content type from template name
    pub fn from_template(template: &str) -> Self {
        let path = std::path::Path::new(template);
        match path.extension().and_then(|s| s.to_str()) {
            Some("html") | Some("htm") => ContentType::Html,
            Some("xml") => ContentType::Xml,
            Some("json") => ContentType::Json,
            Some("txt") | Some("text") => ContentType::Text,
            _ => ContentType::Html, // default
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_content_type_from_template() {
        assert_eq!(ContentType::from_template("page.html"), ContentType::Html);
        assert_eq!(ContentType::from_template("post.htm"), ContentType::Html);
        assert_eq!(ContentType::from_template("feed.xml"), ContentType::Xml);
        assert_eq!(ContentType::from_template("data.json"), ContentType::Json);
        assert_eq!(ContentType::from_template("robots.txt"), ContentType::Text);
        assert_eq!(ContentType::from_template("unknown.foo"), ContentType::Html);
    }

    #[test]
    fn test_virtual_outputs() {
        use std::path::PathBuf;

        let metadata = ContentMetadata {
            path: PathBuf::from("test.md"),
            components: vec!["test".to_string()],
            filename: "index.html".to_string(),
            template_name: "page.html".to_string(),
            content_type: ContentType::Html,
            language: "en".to_string(),
            permalink: "http://example.com/test/".to_string(),
        };

        let package = OutputPackage::new(
            "Test content".to_string(),
            metadata,
            Arc::new(config::Config::default_for_test()),
        );

        // Add a virtual output
        let virtual_output = Output {
            data: OutputData::Text("Virtual data".to_string()),
            content_type: ContentType::Json,
            tags: OutputTags::default(),
        };

        package.add_virtual("metadata.json", virtual_output);

        // Verify virtual output exists and has correct tags
        let output = package.get("metadata.json").unwrap();
        assert!(output.tags.is_virtual, "Should be marked as virtual");
        assert!(output.tags.is_derived, "Should be marked as derived");
        assert_eq!(output.data.as_text().unwrap(), "Virtual data");
    }

    #[test]
    fn test_virtual_output_at_custom_location() {
        use std::path::PathBuf;

        let metadata = ContentMetadata {
            path: PathBuf::from("test.md"),
            components: vec!["test".to_string()],
            filename: "index.html".to_string(),
            template_name: "page.html".to_string(),
            content_type: ContentType::Html,
            language: "en".to_string(),
            permalink: "http://example.com/test/".to_string(),
        };

        let package = OutputPackage::new(
            "Test content".to_string(),
            metadata,
            Arc::new(config::Config::default_for_test()),
        );

        // Add a virtual output at a custom location
        let virtual_output = Output {
            data: OutputData::Text("Custom location data".to_string()),
            content_type: ContentType::Text,
            tags: OutputTags::default(),
        };

        package.add_virtual_at(vec!["custom".to_string()], "data.txt", virtual_output);

        // Verify the output is at the custom location
        let key = OutputKey::new(vec!["custom".to_string()], "data.txt");
        let output = package.outputs.get(&key).unwrap();
        assert!(output.tags.is_virtual, "Should be marked as virtual");
        assert!(output.tags.is_derived, "Should be marked as derived");
        assert_eq!(output.data.as_text().unwrap(), "Custom location data");
    }
}
